# 251215

## 생각한 거
**쓰레드 쪼개서 작업 분배하면**
- 지금은 오버헤드 크고 heap할당 엄청 하는(`std::future`, `std::function`), 그냥 '작동 만'하는 코드인데(perf 찍으면 분할이 70%먹음), 나중에 최적화를 해도 오버헤드는 있을거고

- 작업량이 고정되었을 때, `소요시간 - 작업분할`으로 보든 & 쓰레드가 고정되었을 때, `소요시간 - 작업량`으로 보든 대충 convex한 형태를 띌 것인데

- 아마도 이를 정략적으로 계산 가능한 알고리즘이 무조건 있을 것이므로 (아니면 정량적으로 기록을 해서 분할 지표(e.g. database query optimizer?)로 삼든.)

- 한 작업이 분할 가능한 형태일 때 -> 나누는 최소한의 단위를 정할 수 있을 듯. 컴파일타임 상수가 될지, 런타임 변수가 될지는 모르겠다만.

**연산 소요 시간을 정략적으로 계산할 수 있느냐?**
- 환경변수가 너무 많아서 어떨지 모르곘네 (`E. Sohn et al., "Toward Performance Prediction in Large-Scale Systems through Temporal System and Application Log Analysis," 2025 IEEE` 등)

    - hw가 dedicate한가? 발열, 쓰로틀링은? OS는? ...

- margin을 둬서 최소한의 보장을 구축한다면, 낭비되는 분량을 보상할 수준의 가치가 있는가?
    - 그 기준은? 68%? 95%? 99.7%?

- node내에서 thread에 작업을 분배하는건가, node들에 작업을 분배하는건가?

## 한 거
- 현 상황에서는 fp16의 이점이 딱히 없다는 걸 깨달음[#](https://www.intel.co.kr/content/www/kr/ko/content-details/669773/intel-avx-512-fp16-instruction-set-for-intel-xeon-processor-based-products-technology-guide.html). 일단 fp32로 통합함.
    - 스케일러블 제온 있긴 한데, 테스트 환경 구축도 안해뒀고, 지금 만드는 거에서는 당장 무시해도 좋을 edge case수준이고....

- 선택 가능한 요소(활성화 함수, 초기화, 최적화 등)의 using의 형태는 다음과 같이 한다:
    - enum: `NameType` (인자로 넘기는 것)
    - 함수포인터: `NameFunc` (최종적으로 enum -> pointer(e.g. funcPointer, unique_ptr)로 resolving하는 것)
    - example
        - `ActType`, `InitType`, `OptType`
        - `ActFunc`, `InitFunc`, `OptFunc`
- 구조가 바뀌는 와중에 파라미터 세이브 모듈을 그때그때 수정하는 건 비효율적인 거 같음. 한동안 비활성화.