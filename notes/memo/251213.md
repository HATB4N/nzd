# 251213

## memo
메모리 관리(발급) & 캐시 관리 & 자료형(matrix_t) 3개를 분리한다.

간단한 context, string 저장 등은 kernl에서 알아서 malloc해주는 거 받아 쓰는데, parms를 위한 대량의 malloc은 파편화 등을 고려해야 한다.

이에 따라:
- 연속 메모리 풀 소유 & 발급을 하는 메모리 관리자
- 원본 행렬의 주소만을 소유하는 matrix_t(`Common/Struct.h`, 현재는 tranposed & not-tranposed 둘 다 소유, 각각의 dirty관리. 책임 분할 필요함)
- 행렬 identifier - caches를 mapping & 메모리 전체 용량을 확인하며 적절히 eviction을 수행햐는 캐시 manager

또한 `Common/Gemm.h`은 최소한의 state나 context만을 참조하는 라우터로 역할을 수정한다.
- 연산 요청 -> 연산자(e.g. `Common/Matrix.h`) routing
- 연산자 -> cache manager routing

연산자는 현재 `Common/Matrix.h`로 유일하지만, 아키텍쳐 등에 따라 avx, neon등을 직접 사용하는 연산자의 추가를 고려하자. (req routing?)
- 연산자 공용 인터페이스
- 라우팅은 gemm.h에서 (mux/demux? routing? idk)

## etc
test vector = mnist 60k imgs & test set 학습 됨.
```
*[main][~/Dev/nzd]$ ./NZD
======================
from . import machine

machine.learn()
======================

[MNIST]: init done, all data loaded into memory.
[Epoches 1 / 30] started.
Batch Loss: 2.36421
[Epoches 2 / 30] started.
Batch Loss: 0.238769

...

Batch Loss: 0.0034948
[Epoches 29 / 30] started.
Batch Loss: 0.000576168
[Epoches 30 / 30] started.
Batch Loss: 0.000753915
[MNIST]: init done, all data loaded into memory.

----- Test Results -----
Average Loss: 0.105067
Accuracy: 97.77 %
------------------------
```

test conf
- 출력층 softamx
- 손실함수 cross entropy
- One-hot encoding으로 dZ 직접 주입
- forward fp16, backward fp32

test cases
- case 1
    - 배치 256
    - Lr 0.001 수렴 안함 (NaN)
- case 2
    - 배치 256
    - Lr 0.003 수렴하다가 발산 (정답률 15%미만)

- case 3
    - 배치 128
    - Lr 0.001 안정적으로 수렴

- case 4
    - Xavier + linear 정답률 90정도
    - He + linear 수렴안함
     -He + l_relu(0.01) 정답률 97.69

- case 5: He + relu @ various hidden dim config
    - 3 layer 64 정답률 97.71
    - 3 layer 512 정답률 98.25
    - 10 layer 64 정답률 97.3
    - 10 layer 512 정답률 98.29

할 일
- batch normalization, lasso, dropout 등 구현 하기
- IOptimizers (경사하강 관련 인터페이스) 구현체 안쓰고, update에서 W := W - lr*dW로 테스트만 돌림. 추후에 제대로 구현할 것.